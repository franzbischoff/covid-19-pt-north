---
title: "SIR Model for Portugal - North Region"
bibliography: references.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/american-medical-association.csl
output: 
  html_notebook: 
    code_folding: hide
    fig_caption: yes
    number_sections: yes
    theme: united
    toc: yes
    fig_width: 10
    fig_height: 6
creative_commons: CC BY-SA
editor_options: 
  chunk_output_type: inline
---

<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-160033971-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-160033971-2');
</script>
</head> 

Last Updated: `r lubridate::now("UTC")` UTC

# Disclaimer

This is an independent simulation and does not reflect any portuguese governmental position about the subject.

This is a work in progress.

# Concepts

- **Incubation Period**: is the time between infection and the visible appearance of symptoms.
- **Latency period**: is the period of time between infection and the ability to infect someone.

# Model Hypothesis

## Compartments

The population is assumed to be divided in compartments, for example:

- **Susceptible** individuals
- **Infected**, symptomatic and infectious
- **Recovered**, immune from further infection

## Discrete time

The observations, for simplicity, will be analyzed as a *discrete* time-series.
In this case we will use `days`.

## Population

The total number of individuals is modeled using currently available data for birth and death rates.

## Other assumptions

- The population is considered big, so the random effects can be ignored.
- The population is considered homogeneous at any point in time. This means that the individuals of any compartment are distributed randomically.
- The disease is transmitted *by proximity or contact* between an infected and a susceptible individual (individual contact model - ICM).
- The susceptible individual becomes infected instantaneously.
- The infected individuals may or may not be infectious, until they get symptoms.
- The infected eventually get recovered and *become immune*, or die.
- The *population pyramid* is taking in account for disease severity.

```{r setup, include=FALSE}
version_date <- lubridate::ymd("2020-04-11")

knitr::opts_chunk$set(
  warnings = TRUE,
  echo = FALSE,
  cache = FALSE,
  prompt = FALSE,
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 60)
)
# Install package if needed
if (!requireNamespace("EpiModel", quietly = TRUE)) {
  devtools::install_github("statnet/EpiModel", quiet = TRUE)
}
if (!requireNamespace("ggridges", quietly = TRUE)) {
  install.packages("ggridges", quiet = TRUE)
}
if (!requireNamespace("incidence", quietly = TRUE)) {
  install.packages("incidence", quiet = TRUE)
}
if (!requireNamespace("sodium", quietly = TRUE)) {
  system("apt install libsodium-dev")
  install.packages("sodium", quiet = TRUE)
}
if (!requireNamespace("epitrix", quietly = TRUE)) {
  install.packages("epitrix", quiet = TRUE)
}
if (!requireNamespace("earlyR", quietly = TRUE)) {
  install.packages("earlyR", quiet = TRUE)
}
if (!requireNamespace("jsonlite", quietly = TRUE)) {
  install.packages("jsonlite", quiet = TRUE)
}
if (!requireNamespace("DiagrammeR", quietly = TRUE)) {
  install.packages("DiagrammeR", quiet = TRUE)
}
if (!requireNamespace("gt", quietly = TRUE)) {
  devtools::install_github("rstudio/gt", quiet = TRUE)
}
if (!requireNamespace("plotly", quietly = TRUE)) {
  install.packages("plotly", quiet = TRUE)
}

# Load EpiModel
suppressMessages(library(EpiModel))
suppressMessages(library(EpiEstim))
suppressMessages(library(tidyverse))
suppressMessages(library(ggridges))
suppressMessages(library(incidence))
suppressMessages(library(earlyR))
suppressMessages(library(jsonlite))
suppressMessages(library(DiagrammeR))
suppressMessages(library(gt))
suppressMessages(library(foreach))
suppressMessages(library(parallel))
suppressMessages(library(plotly))

if (requireNamespace("conflicted", quietly = TRUE)) {
  conflicted::conflict_prefer("lag", "dplyr")
  conflicted::conflict_prefer("filter", "dplyr")
  conflicted::conflict_prefer("layout", "plotly")
}
```

```{r monkey patch, echo=FALSE}

# Extension to EpiModel patch, by Tim Churches, with little changes
source_files <- c(
  "_icm.mod.init.seiqhrf.R",
  "_icm.mod.status.seiqhrf.R",
  "_icm.mod.vital.seiqhrf.R",
  "_icm.control.seiqhrf.R",
  "_icm.utils.seiqhrf.R",
  "_icm.saveout.seiqhrf.R",
  "_icm.icm.seiqhrf.R"
)

for (source_file in source_files) {
  source(paste0("./ext/", source_file))
}
```

```{r fetch data, echo=FALSE}

# Get data from DGS if the cache file is from yesterday
if (!file.exists("../data/dgs.rda") | file.info("../data/dgs.rda")$mtime < lubridate::today()) {
  dgs_cases_url <- "https://services.arcgis.com/CCZiGSEQbAxxFVh3/arcgis/rest/services/COVID19Portugal_view/FeatureServer/0/query?f=json&where=1=1&returnGeometry=false&spatialRel=esriSpatialRelIntersects&outFields=*&orderByFields=datarelatorio asc&resultOffset=0&resultRecordCount=1000"
  dgs_extra_url <- "https://services.arcgis.com/CCZiGSEQbAxxFVh3/arcgis/rest/services/An%C3%A1lises_Extra_Covid/FeatureServer/0/query?f=json&where=1%3D1&returnGeometry=false&spatialRel=esriSpatialRelIntersects&outFields=*&orderByFields=Data_do_Relat%C3%B3rio%20asc&resultOffset=0&resultRecordCount=2000&cacheHint=true"
  dgs_geo_url <- "https://services.arcgis.com/CCZiGSEQbAxxFVh3/arcgis/rest/services/COVID19Portugal_view/FeatureServer/1/query?f=json&where=1=1&returnGeometry=false&spatialRel=esriSpatialRelIntersects&outFields=*&orderByFields=dist_casosconf desc&resultOffset=0&resultRecordCount=1000"

  dgs_cases <- fromJSON(URLencode(dgs_cases_url))
  dgs_extra <- fromJSON(URLencode(dgs_extra_url))
  dgs_geo <- fromJSON(URLencode(dgs_geo_url))

  # save cache file
  save(dgs_cases, dgs_extra, dgs_geo, file = "../data/dgs.rda")
} else {
  # load cache file
  load("../data/dgs.rda")
}
```

```{r tidy data, echo=FALSE}

# dataset with information by geographic location ----
geo_dataset <- dgs_geo[["features"]][["attributes"]]
geo_colnames <- c(
  "id_objeto", "id_global", "data_relatorio", "distrito",
  "casos_confirmados", "n_obitos", "recuperados", "id_global_pai",
  "creation_date", "creator", "edit_date", "editor", "untimo_registo"
)
names(geo_dataset) <- geo_colnames

geo_dataset$data_relatorio <- as.Date(as.POSIXct(geo_dataset$data_relatorio / 1000, origin = "1970-01-01"))
geo_dataset$creation_date <- as.Date(as.POSIXct(geo_dataset$creation_date / 1000, origin = "1970-01-01"))
geo_dataset$edit_date <- as.Date(as.POSIXct(geo_dataset$edit_date / 1000, origin = "1970-01-01"))

# filter data for only north of Portugal ----
geo_norte <- geo_dataset %>%
  filter(distrito == "+041.45756_-007.67865") %>%
  distinct_at(vars(data_relatorio), .keep_all = TRUE) %>%
  arrange(data_relatorio) %>%
  mutate(id_objeto = seq(13, n() + 13 - 1))

# estimated report rate, using the algorithm from https://cmmid.github.io/visualisations/inferring-covid19-cases-from-deaths
report_rate <- c(
  rep(0.15, 28), 0.17, 0.19, 0.22, 0.26, 0.28, 0.28, 0.30, 0.31,
  0.32, 0.33, 0.34, 0.33, 0.33, 0.32, 0.33, 0.34, 0.36
)

report_rate <- c(report_rate, rep(tail(report_rate, 1), tail(geo_norte$id_objeto, 1) - length(report_rate)))

geo_norte <- cbind(geo_norte, report_rate = tail(report_rate, nrow(geo_norte)))

# whole Portugal dataset ----

cases_dataset <- dgs_cases[["features"]][["attributes"]]
colnames <- c(
  "id_objeto", "id_global", "data_relatorio", "casos_confirmados",
  "n_obitos", "recuperados", "casos_suspeitos", "casos_masculinos",
  "casos_femininos", "gr_etario_0_9", "gr_etario_10_19", "gr_etario_20_29",
  "gr_etario_30_39", "gr_etario_40_49", "gr_etario_50_59", "gr_etario_60_69",
  "gr_etario_70_79", "gr_etario_80_89", "gr_etario_90_99", "casos_importados",
  "casos_contacto", "sintoma_febre", "sintoma_tosse", "sintoma_dores",
  "sintoma_cefaleia", "sintoma_fraqueza", "creation_date", "creator", "edit_date",
  "editor", "casos_novos", "sintoma_difrespiratoria", "ultimo_registo",
  "estrangeiro", "casos_ativos", "aguarda_resultado", "contatos_vigilancia",
  "cadeias_transmissao", "casos_internados", "casos_internados_uci"
)
names(cases_dataset) <- colnames
cases_dataset$data_relatorio <- as.Date(as.POSIXct(cases_dataset$data_relatorio / 1000, origin = "1970-01-01"))
cases_dataset$edit_date <- as.POSIXct(cases_dataset$edit_date / 1000, origin = "1970-01-01")
cases_dataset$creation_date <- as.POSIXct(cases_dataset$creation_date / 1000, origin = "1970-01-01")

# remove rows that have all NA in a selection of columns
cases_dataset <- cases_dataset %>% filter_at(vars(casos_confirmados:sintoma_fraqueza), any_vars(!is.na(.)))

cases_dataset <- cases_dataset %>%
  select(
    id_objeto, data_relatorio, casos_confirmados, casos_novos,
    casos_suspeitos, recuperados, n_obitos, casos_masculinos, casos_femininos,
    casos_importados, casos_contacto, estrangeiro, casos_ativos, aguarda_resultado,
    gr_etario_0_9, gr_etario_10_19, gr_etario_20_29, gr_etario_30_39,
    gr_etario_40_49, gr_etario_50_59, gr_etario_60_69, gr_etario_70_79,
    gr_etario_80_89, gr_etario_90_99, contatos_vigilancia,
    casos_internados, casos_internados_uci, sintoma_febre, sintoma_tosse,
    sintoma_dores, sintoma_cefaleia, sintoma_fraqueza, sintoma_difrespiratoria
  ) %>%
  arrange(data_relatorio) %>%
  distinct_at(vars(data_relatorio:sintoma_difrespiratoria), .keep_all = TRUE) %>%
  mutate(id_objeto = 1:n())

# New extra information from whole Portugal ----

extra_dataset <- dgs_extra[["features"]][["attributes"]]
colnames <- c(
  "data_relatorio", "casos_confirmados", "casos_confirmados_evo",
  "recuperados", "recuperados_evo", "n_obitos", "n_obitos_evo",
  "casos_suspeitos", "casos_suspeitos_evo", "casos_nao_confirmados",
  # "gr_etario_0_9", "gr_etario_10_19", "gr_etario_20_29", "gr_etario_30_39",
  # "gr_etario_40_49", "gr_etario_50_59", "gr_etario_60_69", "gr_etario_70_79",
  # "gr_etario_80_",
  "aguarda_resultado", "amostras", "amostras_novas",
  "casos_novos", "fid"
)
names(extra_dataset) <- colnames
extra_dataset$data_relatorio <- as.Date(as.POSIXct(extra_dataset$data_relatorio / 1000, origin = "1970-01-01"))

extra_dataset <- extra_dataset %>%
  arrange(data_relatorio) %>%
  mutate(id_objeto = 1:n())
```

```{r check data, eval=FALSE, warning=FALSE, include=FALSE}
# Internal quality check ----

by_age <- cases_dataset %>%
  select(starts_with("gr_etario")) %>%
  rowSums(na.rm = T)
by_sex <- cases_dataset$casos_masculinos + cases_dataset$casos_femininos
by_transmission <- cases_dataset$casos_contacto + cases_dataset$casos_importados
by_status <- cases_dataset$recuperados + cases_dataset$n_obitos + cases_dataset$casos_ativos

if (!identical(cases_dataset$casos_confirmados, by_status)) {
  err <- which(cases_dataset$casos_confirmados != by_status)

  for (n in err) {
    cat(paste0(
      "Incongruência no dia ", cases_dataset$data_relatorio[n],
      " Confirmados: ", cases_dataset$casos_confirmados[n],
      ", ativos + obitos+ recuperados: ", by_status[n], "\n"
    ))
  }
}

if (!identical(cases_dataset$casos_confirmados, by_age)) {
  err <- which(cases_dataset$casos_confirmados != by_age)

  for (n in err) {
    cat(paste0(
      "Incongruência no dia ", cases_dataset$data_relatorio[n],
      " Confirmados: ", cases_dataset$casos_confirmados[n],
      ", Soma das faixas etárias: ", by_age[n], "\n"
    ))
  }
}

if (!identical(cases_dataset$casos_confirmados, by_sex)) {
  err <- which(cases_dataset$casos_confirmados != by_sex)

  for (n in err) {
    cat(paste0(
      "Incongruência no dia ", cases_dataset$data_relatorio[n],
      " Confirmados: ", cases_dataset$casos_confirmados[n],
      ", Homens + Mulheres: ", by_sex[n], "\n"
    ))
  }
}

if (!identical(cases_dataset$casos_confirmados, by_transmission)) {
  err <- which(cases_dataset$casos_confirmados != by_transmission)

  for (n in err) {
    cat(paste0(
      "Incongruência no dia ", cases_dataset$data_relatorio[n],
      " Confirmados: ", cases_dataset$casos_confirmados[n],
      ", Contato + Importados: ", by_transmission[n], "\n"
    ))
  }
}
```

# Extended Model

A more complex model is proposed by Tim Churches[@churches2020modellingcovid19rpart2], adding several compartments and permit a better exploration of the potential effects of various combinations and timings of interventions on COVID-19 spread.

Attention to the description of each compartment:

| Compartment | Functional definition                                                             |
|-------------|-----------------------------------------------------------------------------------|
| S           | Susceptible individuals                                                           |
| E           | Exposed **and** infected, not yet symptomatic but potentially infectious          |
| I           | Infected, symptomatic **and** infectious                                          |
| Q           | Infectious, but (self-)isolated                                                   |
| H           | Requiring hospitalisation (would normally be hospitalised if capacity available)  |
| R           | Recovered, immune from further infection                                          |
| F           | Case fatality (death due to COVID-19, not other causes)                           |

## Transition diagram

```{r flow chart, echo=FALSE, fig.height=6, fig.width=10, fig.align="center"}
grViz("
digraph SEIQHRF {

  # a 'graph' statement
  graph [overlap = false, fontsize = 12, fontname = Helvetica
  labelloc='b', label='\nAdapted from timchurches.github.io/blog'] #, rankdir = LR]

  # several 'node' statements
  node [shape = box, fontname = Helvetica]
  S[label='S=Susceptible'];
  E[label='E=Exposed and infected,\nasymptomatic,\npotentially infectious'];
  I[label='I=Infected and infectious'];
  Q[label='Q=(Self-)isolated\n(infectious)'];
  H[label='H=Requires\nhospitalisation'];
  R[label='R=Recovered/immune'];
  F[label='F=Case fatality']

  # several 'edge' statements
  S->E[label='a']
  I->S[style='dashed', label='x']
  E->I[label='b']
  E->S[style='dashed', label='y']
  I->Q[label='c']
  Q->S[style='dashed', label='z']
  I->R[label='d']
  I->H[label='e']
  H->F[label='f']
  H->R[label='g']
  Q->R[label='h']
  Q->H[label='i']
}
")
```

## Parameters

There is **a lot** of parameters. We will start with the defaults and adjust accordingly to new evidences.

The full list of parameters is available in the source code.

```{r parameters, eval=FALSE, include=FALSE}
param_docs <- tribble(
  ~DiagramRef, ~Parameter, ~Default, ~Explanation,
  "", "type", "SEIQHRF", "Type of model: SI, SIR, SIS, SEIR, SEIQHR and SEIQHRF available, but only SEIQHRF is likely to work in the current version of the code.",

  "", "nsteps", 366, "Number of days for simulation. Note that day 1 is for initialisation, day 2 is the first day of the simulation, hence default of 366 for 1 year.",

  "", "nsims", 10, "Number of simulations to run and then average.",

  "", "ncores", 10, "Number of CPU cores to use for parallel execution.",

  "b", "prog.rand", FALSE, "Method for progression from E compartment to I. If TRUE, random binomial draws at `prog.rate`, if FALSE, random draws from a Weibull distribution (yes, I know it should be a discrete Weibull distribution but it makes little difference and speed of computation matters), with parameters `prog.dist.scale` and  `prog.dist.shape`",

  "d,g,h", "rec.rand", FALSE, "Method for recovery transition from I, Q or H to R. If TRUE, random binomial draws at `rec.rate`, if FALSE, random draws from a random draws from a Weibull distribution, with parameters `rec.dist.scale` and  `rec.dist.shape`",

  "f", "fat.rand", FALSE, "Method for case fatality transition from H to F. If TRUE, random binomial draws at `fat.rate.base`, if FALSE, random sample with a sample fraction also given by `fat.rate.base`. However, if the current number of patients in the H (needs hospitalisation) compartment is above a hospital capacity level specified by `hosp.cap`, then the fatality rate is the mean of the base fatality rate weighted by the hospital capacity, plus a higher rate, specified by `fat.rate.overcap`, weighted by the balance of those requiring hospitalisation (but who can't be accommodated). By setting `fat.rate.overcap` higher, the effect of exceeding the capacity of the health care system can be simulated. There is also a coefficient `fat.tcoeff` for the fatality rates that increases them as a linear function of the number of days the individual has been in the H compartment. Use of the co-efficient better approximates the trapezoid survival time distribution typical of ICU patients.",

  "c", "quar.rand", FALSE, "Method for self-isolation transition from I to Q. If TRUE, random binomial draws at `quar.rate`, if FALSE, random sample with a sample fraction also given by `quar.rate.",

  "e,i", "hosp.rand", FALSE, "Method for transition from I or Q to H -- that is, from infectious or from self-isolated to requiring hospitalisation. If TRUE, random binomial draws at `hosp.rate`, if FALSE, random sample with a sample fraction also given by `hosp.rate.",

  "g", "disch.rand", FALSE, "Method for transition from H to R -- that is, from requiring hospitalisation to recovered. If TRUE, random binomial draws at `disch.rate`, if FALSE, random sample with a sample fraction also given by `disch.rate`. Note that the only way out of the **H** compartment is recovery or death.  ",

  "", "infection.FUN", "infection.seiqhrf.icm", "No, being infected with SARS-CoV2 is **not** fun. Rather this is the the name of the function to implement infection processes. Use the default.",

  "", "departures.FUN", "departures.seiqhrf.icm", "Handles background demographics, specifically departures (deaths not due to the virus, and emigration). Use the default.",

  "", "arrivals.FUN", "arrivals.icm", "Handles background demographics, specifically arrivals (births and immigration). Uses the original EpiModel code currently. A replacement that implements modelling the arrival of infected individuals is under development -- but for now, all arrivals go into the **S** compartment.",

  "", "get_prev.FUN", "get_prev.seiqhrf.icm", "Utility function that collects prevalence and transition time data from each run and stores it away in the simulation result object. Use the default.",

  "", "s.num", "9997", "Initial number of **S* compartment individuals in the simulated population. An overall population of 10,000 is a good compromise. A set of models will still take several minutes or more to run, in parallel. ",

  "", "e.num", "0", "Initial number of **E** compartment individuals in the simulated population.",

  "", "i.num", "3", "Initial number of **I** compartment individuals in the simulated population.",

  "", "q.num", "0", "Initial number of **Q** compartment individuals in the simulated population.",

  "", "h.num", "0", "Initial number of **H** compartment individuals in the simulated population.",

  "", "r.num", "0", "Initial number of **R** compartment individuals in the simulated population.",

  "", "f.num", "0", "Initial number of **F** compartment individuals in the simulated population.",

  "x", "act.rate.i", "10", "The number of exposure events (_acts_) between infectious individuals in the **I** compartment and susceptible individuals in the **S** compartment, per day. It's stochastic, so the rate is an average, some individuals may have more or less. Note that not every exposure event results in infection - that is governed by the `inf.prob.i` parameters (see below). Reducing `act.rate.i` is equivalent to increasing social distancing by people in the **I** compartment.",

  "x", "inf.prob.i", "0.05", "Probability of passing on infection at each exposure event for interactions between infectious people in the **I** compartment and susceptibles in **S**. Reducing `inf.prob.i` is equivalent to increasing hygiene measures, such as not putting hands in eyes, nose or moth, use of hand sanitisers, wearing masks by the infected, and so on.",

  "y", "act.rate.e", "10", "The number of exposure events (_acts_) between infectious individuals in the **E** compartment and susceptible individuals in the **S** compartment, per day. Otherwise as for `act.rate.i`.",

  "y", "inf.prob.e", "0.02", "Probability of passing on infection at each exposure event for interactions between infectious people in the **E** compartment and susceptibles in **S**. Note the default is lower than for `inf.prob.i` reflecting the reduced infectivity of infected but asymptomatic people (the **E** compartment). Otherwise as for `inf.prob.i`.",

  "z", "act.rate.q", "2.5", "The number of exposure events (_acts_) between infectious individuals in the **Q** compartment (isolated, self or otherwise) and susceptible individuals in the **S** compartment, per day. Note the much lower rate than for the **I** and **E** compartments, reflecting the much greater degree of social isolation for someone in (self-)isolation. The exposure event rate is not zero for this group, just much less. Otherwise as for `act.rate.i`.",

  "z", "inf.prob.q", "0.02", "Probability of passing on infection at each exposure event for interactions between infectious people in the **Q** compartment and susceptibles in **S**. Note the default is lower than for `inf.prob.i` reflecting the greater care that self-isolated individuals will, on average, take regarding hygiene measures, such as wearing masks, to limit spread to others. Otherwise as for `inf.prob.i`.",

  "c", "quar.rate", "1/30", "Rate per day at which symptomatic (or tested positive), infected **I** compartment people enter self-isolation (**Q** compartment). Asymptomatic **E** compartment people can't enter self-isolation because they don't yet know they are infected. Default is a low rate reflecting low community awareness or compliance with self-isolation requirements or practices, but this can be tweaked when exploring scenarios.",

  "e,i", "hosp.rate", "1/100", "Rate **per day** at which symptomatic (or tested positive), infected **I** compartment people or self-isolated **Q** compartment people enter the state of requiring hospital care -- that is, become serious cases. A default rate of 1% per day with an average illness duration of about 10 days means a bit less than 10% of cases will require hospitalisation, which seems about right (but can be tweaked, of course).",

  "g", "disch.rate", "1/15", "Rate per day at which people needing hospitalisation recover.",

  "b", "prog.rate", "1/10", "Rate per day at which people who are infected but asymptomatic (**E** compartment) progress to becoming symptomatic (or test-positive), the **I** compartment. See `prog.rand` above for more details.",

  "b", "prog.dist.scale", "5", "Scale parameter for Weibull distribution for progression, see `prog.rand` for details.",

  "b", "prog.dist.shape", "1.5", "Shape parameter for Weibull distribution for progression, see `prog.rand` for details. Read up on the Weibull distribution before changing the default.",

  "d", "rec.rate", "1/20", "Rate per day at which people who are infected and symptomatic (**I** compartment) recover, thus entering the **R** compartment. See `rec.rand` above for more details.",

  "d", "rec.dist.scale", "35", "Scale parameter for Weibull distribution for recovery, see `rec.rand` for details.",

  "d", "rec.dist.shape", "1.5", "Shape parameter for Weibull distribution for recovery, see `rec.rand` for details. Read up on the Weibull distribution before changing the default.",

  "f", "fat.rate.base", "1/50", "Baseline mortality rate per day for people needing hospitalisation (deaths due to the virus). See `fat.rand` for more details.",

  "f", "hosp.cap", "40", "Number of available hospital beds for the modelled population. See `fat.rand` for more details.",

  "f", "fat.rate.overcap", "1/25", "Mortality rate per day for people needing hospitalisation but who can't get into hospital due to the hospitals being full (see `hosp.cap` and `fat.rand`). The default rate is twice that for those who do get into hospital.",

  "f", "fat.tcoeff", "0.5", "Time co-efficient for increasing mortality rate as time in the **H** compartment increases for each individual in it. See `fat.rand` for details.",

  "", "vital", "TRUE", "Enables demographics, that is, arrivals and departures, to and from the simulated population.",

  "", "a.rate", "(10.5/365)/1000", "Background demographic arrival rate. Currently all arrivals go into the **S** compartment, the default is approximately the daily birth rate for Australia. Will be extended to cover immigration in future versions.",

  "", "ds.rate, de.rate, de.rate, dq.rate, dh.rate, dr.rate", "various rates", "Background demographic departure (death not due to virus) rates. Defaults based on Australian crude death rates. Can be used to model emigration as well as deaths.",

  "", "out", "mean", "Summary function for the simulation runs. median is also available, or percentiles, see the `EpiModel` documentation.",
)
param_docs %>%
  gt() %>%
  fmt_markdown(columns = TRUE) %>%
  tab_options(table.width = pct(90))
```

## Time-variant parameters

Several of the simulation parameters can also be varied over time. That is, as well as accepting a single value, they also accept a vector of values with length equal to `nsteps`, the number of days over which the simulation runs. Assuming `nsteps=366`, we can, for example, set `quar.rate = c(rep(1/10,30), rep(1/3, 335))`. That defines a step function in which the transition-to-isolation rate for the **I** compartment is 0.1 for the first 30 days, then steps up to 0.33 thereafter, reflecting, say, a campaign or government edict to self-isolate. Of course, the vector of values can be a smooth function, or can go up then down again, or whatever you wish to model. This is an extremely powerful feature of computational models such as this, and one very hard to incorporate into purely mathematical models.

Most of the parameters for which time-variation is useful support it. If they don't, you will receive an error message (the table above will be updated to include this information later).

# Evidence

## COVID-related
Last checked: 2020-04-11

- Recovery (h, d) = takes at least 15 days
- Exposition to symptoms (b) = median of 5
- Incubation period: 5.1 (2.2 - 11.5)[@2019_novel_coronavirus]
- Symptoms to death: ~15 (11 - 17) (So, Infection to death ~20 days)[@2019_novel_coronavirus]
- Days to double: 8-9 (Case report estimation is 31-48% at 2020-04-11, for R 1.3 and CFR 2.0[@inferring-covid19-cases-from-deaths])
- Mortality rate: 0.85 - 1.31%[@inferring-covid19-cases-from-deaths]

# Baseline simulation

## Parameters used

- Population: 3,574,394 (estimation of 2019 from Census)[@2020_ine]
- Birth rate: 7.7 ‰ [@2020_ine]
- Baseline death rate (any cause): 9.86 ‰ [@2020_transparencia]
- Baseline hospital death rate (any cause): 50.5 ‰ [@2020_transparencia]
- Rates of exposition (table below)
- Report rate (table below)
- Ages and severity (table below)

<br/><br/>

```{r}
events <- tribble(
  ~idx, ~dates, ~pos, ~rate.e, ~rate.i, ~labels,
  16, "2020-03-08", 10, 16, 10, "Suspension of visits to health facilities and prisons",
  18, "2020-03-10", 15, 15, 10, "Suspension of flights from the most affected areas of Italy",
  19, "2020-03-11", 17, 15, 10, "WHO declares pandemic",
  21, "2020-03-13", 20, 10, 7, "Portugal alert status statement",
  21, "2020-03-13", 25, 10, 7, "Closing of museums",
  23, "2020-03-15", 30, 7, 5, "Restrictions on access to commercial spaces",
  24, "2020-03-16", 35, 5, 3, "Suspension of classes",
  24, "2020-03-16", 40, 5, 3, "Close land borders",
  26, "2020-03-18", 45, 5, 2, "Declaration of state of emergency",
  41, "2020-04-02", 50, 3, 2, "Extension of the state of emergency"
)

events %>%
  select(dates, labels, rate.e, rate.i) %>%
  mutate(rate.q = rate.i / 2) %>%
  distinct(dates, .keep_all = TRUE) %>%
  gt() %>%
  cols_label(dates = md("**Date**"), labels = md("**Event**"), rate.e = md("**E-S**"), rate.i = md("**I-S**"), rate.q = md("**Q-S**")) %>%
  fmt_date(vars(dates), date_style = "day_month") %>%
  tab_header(md("**Interaction rates between compartments**")) %>%
  tab_options(table.width = pct(80))
```

```{r eval=FALSE, include=FALSE}
rates
```

<br/><br/><br/>

```{r}
ages <- tribble(
  ~age, ~percent, ~severity,
  0, 0.080340751, 1,
  1, 0.103443363, 1,
  2, 0.111643592, 1,
  3, 0.123541706, 1,
  4, 0.155134254, 1,
  5, 0.153623583, 1,
  6, 0.127566805, 2,
  7, 0.08683997, 3,
  8, 0.057865975, 4
)



ages %>%
  mutate(age = paste0(">=", age * 10), severity = severity * 1.3 / 100) %>%
  gt() %>%
  cols_label(age = md("**Ages**"), percent = md("**Prevalence**"), severity = md("**Fatality rate**")) %>%
  fmt_percent(columns = c("percent", "severity")) %>%
  tab_header(md("**Age piramid and disease fatality rate**")) %>%
  tab_options(table.width = pct(50))
```

<br/><br/><br/>

```{r simulation function, include=FALSE}
# function to set-up and run the baseline simulations
simulate <- function(
                     # control.icm params
                     type = "SEIQHRF",
                     nsteps = 366,
                     nsims = 8,
                     ncores = 1,
                     ages = FALSE,
                     prog.rand = FALSE,
                     rec.rand = FALSE,
                     fat.rand = TRUE,
                     quar.rand = FALSE,
                     hosp.rand = FALSE,
                     disch.rand = TRUE,
                     infection.FUN = infection.seiqhrf.icm,
                     recovery.FUN = progress.seiqhrf.icm,
                     departures.FUN = departures.seiqhrf.icm,
                     arrivals.FUN = arrivals.icm,
                     get_prev.FUN = get_prev.seiqhrf.icm,
                     # init.icm params
                     s.num = 9997,
                     e.num = 0,
                     i.num = 3,
                     q.num = 0,
                     h.num = 0,
                     r.num = 0,
                     f.num = 0,
                     # param.icm params
                     inf.prob.e = 0.02,
                     act.rate.e = 10,
                     inf.prob.i = 0.05,
                     act.rate.i = 10,
                     inf.prob.q = 0.02,
                     act.rate.q = 2.5,
                     quar.rate = 1 / 30,
                     hosp.rate = 1 / 100,
                     disch.rate = 1 / 15,
                     prog.rate = 1 / 10,
                     prog.dist.scale = 5,
                     prog.dist.shape = 1.5,
                     rec.rate = 1 / 20,
                     rec.dist.scale = 35,
                     rec.dist.shape = 1.5,
                     fat.rate.base = 1 / 50,
                     hosp.cap = 40,
                     fat.rate.overcap = 1 / 25,
                     fat.tcoeff = 0.5,
                     vital = TRUE,
                     a.rate = (10.5 / 365) / 1000,
                     a.prop.e = 0.01,
                     a.prop.i = 0.001,
                     a.prop.q = 0.01,
                     ds.rate = (7 / 365) / 1000,
                     de.rate = (7 / 365) / 1000,
                     di.rate = (7 / 365) / 1000,
                     dq.rate = (7 / 365) / 1000,
                     dh.rate = (20 / 365) / 1000,
                     dr.rate = (7 / 365) / 1000,
                     out = "mean") {
  control <- control.icm(
    type = type,
    nsteps = nsteps,
    nsims = nsims,
    ncores = ncores,
    prog.rand = prog.rand,
    rec.rand = rec.rand,
    infection.FUN = infection.FUN,
    recovery.FUN = recovery.FUN,
    arrivals.FUN = arrivals.FUN,
    departures.FUN = departures.FUN,
    get_prev.FUN = get_prev.FUN,
    verbose = TRUE,
    verbose.int = 1
  )

  init <- init.icm(
    s.num = s.num,
    e.num = e.num,
    i.num = i.num,
    q.num = q.num,
    h.num = h.num,
    r.num = r.num,
    f.num = f.num
  )

  param <- param.icm(
    inf.prob.e = inf.prob.e,
    act.rate.e = act.rate.e,
    inf.prob.i = inf.prob.i,
    act.rate.i = act.rate.i,
    inf.prob.q = inf.prob.q,
    act.rate.q = act.rate.q,
    ages = ages,
    quar.rate = quar.rate,
    hosp.rate = hosp.rate,
    disch.rate = disch.rate,
    prog.rate = prog.rate,
    prog.dist.scale = prog.dist.scale,
    prog.dist.shape = prog.dist.shape,
    rec.rate = rec.rate,
    rec.dist.scale = rec.dist.scale,
    rec.dist.shape = rec.dist.shape,
    fat.rate.base = fat.rate.base,
    hosp.cap = hosp.cap,
    fat.rate.overcap = fat.rate.overcap,
    fat.tcoeff = fat.tcoeff,
    vital = vital,
    a.rate = a.rate,
    a.prop.e = a.prop.e,
    a.prop.i = a.prop.i,
    a.prop.q = a.prop.q,
    ds.rate = ds.rate,
    de.rate = de.rate,
    di.rate = di.rate,
    dq.rate = dq.rate,
    dh.rate = dh.rate,
    dr.rate = dr.rate
  )

  sim <- icm.seiqhrf(param, init, control)
  sim_df <- as.data.frame(sim, out = out)

  return(list(sim = sim, df = sim_df))
}
```

```{r simulate, include=FALSE}

# PORDATA
pt_population <- 10260893 # 2020 est
pt_population_norte <- 3574394 # est 2019 ****** 3690681
pt_births <- 86557 # 2019
pt_deaths <- 112411 # 2019 (transparencia.sns.gov.pt)
pt_deaths_norte <- 35239 # 2018 (ine.pt)
pt_hospdeaths <- 36766 # 2019 (transparencia.sns.gov.pt)
pt_hospdeaths_norte <- 13331
pt_admissions <- 660838 # 2019 (transparencia.sns.gov.pt)
pt_admissions_norte <- 263955
pt_birthrate <- pt_births / pt_population * 1000 # 8.435621
pt_birthrate_norte <- 7.7 # ******
pt_emigrrate <- 7.9 # 2018 est
pt_deathrrate <- pt_deaths / pt_population * 1000 # 11.01766
pt_deathrrate_norte <- pt_deaths_norte / pt_population_norte * 1000 # 9.858734
pt_hdeathrrate <- pt_hospdeaths / pt_admissions * 1000 # 55.63542
pt_hdeathrrate_norte <- pt_hospdeaths_norte / pt_admissions_norte * 1000 # 50.50482
pt_hospcap <- 492000

population <- pt_population_norte
start_inf <- 4
hospcap <- pt_hospcap
birthrate <- pt_birthrate_norte
deathrate <- pt_deathrrate_norte
hdeathrrate <- pt_hdeathrrate_norte
steps <- 180

rate.e <- rep(events$rate.e[1], events$idx[1])
rate.i <- rep(events$rate.i[1], events$idx[1])
idx_diff <- c(diff(events$idx), (steps - tail(events$idx, 1)))
for (i in seq_len(nrow(events))) {
  if (events$idx[i] < steps) {
    rate.e <- c(rate.e, rep(events$rate.e[i], idx_diff[i]))
    rate.i <- c(rate.i, rep(events$rate.i[i], idx_diff[i]))
  }
}

params <- list(
  type = "SEIQHRF",
  nsteps = steps,
  nsims = 32,
  ncores = 4,

  ages = ages,

  # init.icm params
  s.num = population,
  e.num = 0,
  i.num = start_inf,
  q.num = 0,
  h.num = 0,
  r.num = 0,
  f.num = 0,
  # param.icm params
  #
  act.rate.e = rate.e, # number of exposure events between E and S. Otherwise as for act.rate.i.
  act.rate.i = rate.i, # number of exposure events between I and S. It's stochastic, so the rate is an average, some individuals may have more or less. Reducing this parameter is equivalent to increasing social distancing by people in the I compartment.
  act.rate.q = rate.i / 2, # number of exposure events between Q and S. Otherwise as for act.rate.i.
  inf.prob.e = 0.02, # Probability of passing on infection from E to S at each exposure event. Note the default is lower than for inf.prob.i reflecting the reduced infectivity of infected but asymptomatic people. Otherwise as for inf.prob.i
  inf.prob.i = 0.05, # Probability of passing on infection from I to S at each exposure event. Reducing inf.prob.i is equivalent to increasing hygiene measures.
  inf.prob.q = 0.02, # Probability of passing on infection from Q to S. Note the default is lower than for inf.prob.i reflecting the greater care that self-isolated individuals will, on average, take regarding hygiene measures, such as wearing masks, to limit spread to others. Otherwise as for inf.prob.i
  #############
  #############
  # weibull is preferred in this case. Weibull models a "time-to-failure" for which
  #  the failure rate is proportional to a power of time. A value of k > 1
  #  indicates that the failure rate increases with time.
  #  Median = 5 days; IQI:
  prog.rand = FALSE, # From Exposed to Infected, FALSE is Weibull, TRUE is binomial
  prog.rate = 1 / 10, # Binomial distribution, only if prog.rand is TRUE
  ##### b -> Exposed to Infected
  prog.dist.scale = 5, # Weibull distribution, only if prog.rand is FALSE
  prog.dist.shape = 1.5, # Weibull distribution, only if prog.rand is FALSE
  #############
  #############
  rec.rand = FALSE, # FALSE is Weibull, TRUE is binomial
  rec.rate = 1 / 20, # Binomial
  ####### d, g, h -> Infected, Quarantine, Hospital to Recovered
  rec.dist.scale = 35, # Weibull
  rec.dist.shape = 1.5, # Weibull
  ############
  ############ f -> H to F
  fat.rand = TRUE, # TRUE is binomial; if FALSE, random sample with a sample
  # fraction also given by fat.rate.base. However, if the current number of patients
  # in the H (needs hospitalization) compartment is above a hospital capacity level
  # specified by hosp.cap, then the fatality rate is the mean of the base fatality
  # rate weighted by the hospital capacity, plus a higher rate, specified by
  # fat.rate.overcap, weighted by the balance of those requiring hospitalization
  # (but who can't be accommodated). By setting fat.rate.overcap higher,
  # the effect of exceeding the capacity of the health care system can be simulated.
  # There is also a coefficient fat.tcoeff for the fatality rates that increases
  # them as a linear function of the number of days the individual has been in the
  # H compartment. Use of the co-efficient better approximates the trapezoid survival
  # time distribution typical of ICU patients.
  fat.rate.base = 1.3 / 100, # 2% in 15 days
  fat.rate.overcap = 1 / 25, # Mortality rate of those needing hospital but no capacity
  fat.tcoeff = 0.5, # Time co-efficient for increasing mortality rate as time in the H compartment increases for each individual in it.
  hosp.cap = hospcap, # 240 UCI
  #################
  #################
  quar.rand = FALSE, # if TRUE, binomial, if FALSE, random sample.
  quar.rate = 1 / 30,
  #################
  #################
  hosp.rand = FALSE, # if TRUE, binomial, if FALSE, random sample.
  hosp.rate = 1 / 100, # i, e -> I,Q to H
  #################
  #################
  disch.rand = TRUE, # If TRUE, binomial, if FALSE, random sample.
  disch.rate = 1 / 15, # g -> H to R
  #################
  #################
  # Background demographic departure (death not due to virus) rates.
  # Defaults based on Australian crude death rates.
  # Can be used to model emigration as well as deaths.
  vital = TRUE, # Enables demographics, that is, arrivals and departures, to and from the simulated population.
  # (10.5 / 365) / 1000, # Arrival rate. Default is approx the daily birth rate of Australia
  a.rate = (birthrate / 365) / 1000,
  a.prop.e = 0.01,
  a.prop.i = 0.001,
  a.prop.q = 0.01,
  ds.rate = (deathrate / 365) / 1000, # Departure rate (death not by virus)
  de.rate = (deathrate / 365) / 1000,
  di.rate = (deathrate / 365) / 1000,
  dq.rate = (deathrate / 365) / 1000,
  dh.rate = (hdeathrrate / 365) / 1000,
  dr.rate = (deathrate / 365) / 1000,
  #################
  # Summary function for the simulation runs. median is also available, or percentiles, see the EpiModel documentation.
  out = "mean"
)

# set.seed(1) ## seed was moved to the extension code, because multithread breaks it.
# baseline_sim <- do.call("simulate", params)
source("../R/plot_sir.R", encoding = "UTF-8")
```

## Distribution of duration in key compartments

```{r get times, echo=FALSE, fig.height=6, fig.width=10, warning=FALSE}
# define a function to extract timings and assemble a data frame
get_times <- function(simulate_results) {
  sim <- simulate_results$sim

  for (s in 1:sim$control$nsims) {
    if (s == 1) {
      times <- sim$times[[paste("sim", s, sep = "")]]
      times <- times %>% mutate(s = s)
    } else {
      times <- times %>%
        bind_rows(sim$times[[paste("sim", s, sep = "")]] %>%
          mutate(s = s))
    }
    gc()
  }

  times <- times %>%
    mutate(
      infTime = ifelse(infTime < 0, -5, infTime),
      expTime = ifelse(expTime < 0, -5, expTime)
    )
  gc()
  times <- times %>% mutate(
    incubation_period = infTime - expTime,
    illness_duration = recovTime - expTime,
    illness_duration_hosp = dischTime - expTime,
    hosp_los = dischTime - hospTime,
    quarantine_delay = quarTime - infTime,
    survival_time = fatTime - infTime
  )
  gc()
  times <- times %>% select(
    s,
    incubation_period,
    quarantine_delay,
    illness_duration,
    illness_duration_hosp,
    hosp_los,
    survival_time
  )
  gc()

  ## most memory intensive part
  times <- pivot_longer(times, -s,
    names_to = "period_type",
    values_to = "duration"
  )
  gc()

  return(times)
}

# times <- get_times(baseline_sim)

plot_times <- times %>%
  filter(duration <= 30) %>%
  mutate(period_type = factor(period_type,
    levels = c(
      "incubation_period",
      "illness_duration",
      "hosp_los",
      "illness_duration_hosp",
      "quarantine_delay",
      "survival_time"
    ),
    labels = c(
      "Incubation",
      "Illness",
      "Hospital care required",
      "Illness (hosp)",
      "Delay entering isolation",
      "Survival time (fatalities)"
    )
  )) %>%
  arrange(period_type) %>%
  add_count(period_type, duration) %>%
  distinct(period_type, duration, n) %>%
  group_by(period_type, .drop = FALSE) %>%
  mutate(n = n / sum(n)) %>%
  ungroup()

fig <- plot_ly(plot_times,
  x = ~duration, y = ~n, colors = "Dark2",
  color = ~period_type,
  yaxis = ~ paste0("y", as.numeric(period_type)), type = "bar"
)
fig <- fig %>% layout(
  title = "Duration frequency distributions in Portugal - North",
  paper_bgcolor = "rgb(255,255,255)", plot_bgcolor = "rgb(229,229,229)",
  xaxis = list(
    title = "Days",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    zeroline = FALSE
  ),
  yaxis = list(
    title = "Density",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    range = c(0, max(plot_times$n) * 1.05),
    zeroline = FALSE
  )
)
fig <- fig %>% subplot(nrows = 3, shareX = TRUE, shareY = TRUE)
fig
```

## Baseline Prevalence

### Overall - Interactive Plot

```{r baseline plot, echo=FALSE, fig.height=6, fig.width=10, warning=FALSE}
plot_ly_sir(baseline_sim, c("e.num", "i.num", "q.num", "h.num", "f.num", "r.num"), events = events)
```

### Comparison with real data - Interactive Plot

```{r simulate2, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
plot_ly_sir(baseline_sim, c("f.num", "h.num", "i.num", "q.num", "e.num", "r.num"), stacked = TRUE, grouped = TRUE, real_data = geo_norte, events = events, log = TRUE)
```

### Basic reproduction number $R_{0}$

```{r baseline R0, echo=FALSE, fig.height=5, fig.width=10, warning=FALSE}
# get the S-> E compartment flow, which is
# our daily incidence rate
incidence_counts <- baseline_sim$df %>%
  select(time, se.flow)
# uncount them
incident_case_dates <- incidence_counts %>%
  uncount(se.flow) %>%
  pull(time)
incident_case_dates <- as.Date("2020-02-28") + incident_case_dates
# convert to an incidence object
incidence_all <- as.data.frame(incidence(incident_case_dates))

fig <- plot_ly(incidence_all, x = ~dates, y = ~counts, type = "bar")

fig <- fig %>% layout(
  title = "Daily incidence in Portugal - North",
  paper_bgcolor = "rgb(255,255,255)", plot_bgcolor = "rgb(229,229,229)",
  xaxis = list(
    title = "Date",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    zeroline = FALSE
  ),
  yaxis = list(
    title = "Cases",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    zeroline = FALSE
  )
)
fig
```


```{r message=FALSE, fig.height=5, fig.width=10, warning=FALSE}
# find the peak of the epidemic curve
peak_of_epidemic_curve <- find_peak(incidence(incident_case_dates))

incidence_growth_phase <- incidence(incident_case_dates, last_date = peak_of_epidemic_curve)
# specify serial interval mean and SD
# since the last blog post new studies have appeared
# suggesting 4.5 is a better mean for the SI
si_mean <- 4.5
si_sd <- 3.4

# get a set of MLE estimates for R0 and plot
smooth_it <- lowess(incidence_growth_phase$counts, f = 0.3)$y
smooth_it <- smooth_it - min(smooth_it)
res <- get_R(smooth_it, si_mean = si_mean, si_sd = si_sd)

fig <- plot_ly(x = ~ res$R_grid, y = ~ res$R_like) %>% add_lines()

fig <- fig %>% layout(
  title = "Likelihood distribution of R",
  paper_bgcolor = "rgb(255,255,255)", plot_bgcolor = "rgb(229,229,229)",
  xaxis = list(
    title = "Reproduction Number (R)",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    zeroline = FALSE
  ),
  yaxis = list(
    title = "Likelihood",
    gridcolor = "rgb(255,255,255)",
    showgrid = TRUE,
    showline = FALSE,
    showticklabels = TRUE,
    tickcolor = "rgb(127,127,127)",
    ticks = "outside",
    zeroline = FALSE
  )
)
fig
sample <- earlyR::sample_R(res, 10000)
cat(paste0("Estimated R is ", round(mean(sample), 2), " (±", round(2 * sd(sample), 2), ")"))
```

```{r Rt, echo=FALSE, fig.height=3, fig.width=10, message = FALSE, warning=FALSE}
# 5.6 ( 4.7 - 6.9 ) https://www.anmsp.pt/covid19-mapa
# 0.7 ( 0.7 - 0.8 )
si_mean <- 5.6
si_mean_sd <- 0.5
si_sd <- 2.3
si_sd_sd <- 0.5

est <- estimate_R(incidence(incident_case_dates, last_date = today() + 2),
  method = "uncertain_si",
  config = make_config(list(
    mean_si = si_mean,
    std_mean_si = si_mean_sd,
    min_mean_si = si_mean - 2 * si_mean_sd, max_mean_si = si_mean + 2 * si_mean_sd,
    std_si = si_sd,
    std_std_si = si_sd_sd,
    min_std_si = si_sd - 2 * si_sd_sd, max_std_si = si_sd + 2 * si_sd_sd,
    n1 = 100, n2 = 100,
    seed = 1
  ))
)

ggplotly(plot(est, "R"))
ggplotly(plot(est, "SI"))

# SL = c(5, 9, 7, 3, 7, 8, 1, 3, 7, 9, 12)
# 
# si_data_wuhan_Li <- data.frame(EL = as.integer(rep(0, 11)), ER = as.integer(rep(1, 
#     11)), SL = as.integer(SL), SR = as.integer(SL + 1))
# 
# ## fixing the random seeds
# MCMC_seed <- 1
# overall_seed <- 2
# dist <- "G" # fitting a Gamma distribution for the SI
# hubei_res_empirical_si <- estimate_R(incidence(incident_case_dates),
#   method = "si_from_data",
#   si_data = si_data_wuhan_Li,
#   config = make_config(list(
#     si_parametric_distr = dist,
#     mcmc_control = make_mcmc_control(seed = MCMC_seed, burnin = 1000),
#     seed = overall_seed,
#     n1 = 50,
#     n2 = 50
#   ))
# )
# 
# plot(hubei_res_empirical_si)
```



# Running an intervention experiments

Work in progress...

# Acknowledgments

This simulations are heavily based on Tim Churches' code, available [here](https://timchurches.github.io/blog/).
